"""
Unified LLM client with Groq primary and Gemini fallback
Handles automatic failover and key rotation for both providers
"""

import time
from typing import Tuple, Optional

from src.core.groq_client import GroqClient
from src.core.gemini_client import GeminiClient
from src.core.api_key_manager import APIKeyManager
from src.core.groq_key_manager import GroqKeyManager
from src.utils.config import Config
from src.utils.logger import setup_logger
from src.utils.exceptions import APIError

logger = setup_logger(__name__)


class UnifiedLLMClient:
    """
    LLM client that tries Groq first with rotation, falls back to Gemini with rotation
    
    Features:
    - Groq primary (14,400 req/day per key, fast, cost-effective)
    - Gemini fallback (50 req/day per key, reliable, proven)
    - **Automatic key rotation** for both providers on rate limits
    - Transparent failover on any error
    - Detailed logging of provider and key usage
    - Compatible with existing code (same interface as GeminiClient)
    
    Strategy:
    1. Try Groq with current key
    2. If Groq rate limit → rotate to next Groq key, retry
    3. If all Groq keys exhausted → try Gemini
    4. If Gemini rate limit → rotate to next Gemini key, retry
    5. If all keys exhausted → raise error
    
    Example:
        >>> client = UnifiedLLMClient()
        >>> text, provider = client.generate_content(prompt)
        >>> print(f"Generated by: {provider}")  # "groq" or "gemini"
    """
    
    def __init__(self):
        """
        Initialize both Groq and Gemini clients with key rotation
        
        Groq is primary, Gemini is fallback. System can work with:
        - Groq only (if GROQ_API_KEY set, GOOGLE_API_KEY unset)
        - Gemini only (if GOOGLE_API_KEY set, GROQ_API_KEY unset) 
        - Both (recommended: Groq primary, Gemini fallback)
        
        Raises:
            APIError: If neither client can be initialized
        """
        self.groq_client: Optional[GroqClient] = None
        self.gemini_client: Optional[GeminiClient] = None
        self.groq_key_manager: Optional[GroqKeyManager] = None
        self.gemini_key_manager = APIKeyManager()
        
        # Try to initialize Groq (primary)
        groq_keys = Config.get_all_groq_api_keys()
        if groq_keys and groq_keys[0] != "your-groq-api-key-here":
            try:
                self.groq_key_manager = GroqKeyManager()
                groq_key = self.groq_key_manager.get_current_key()
                self.groq_client = GroqClient(api_key=groq_key)
                logger.info(f"✅ Groq client initialized (primary) - {self.groq_key_manager.get_total_keys()} key(s) available")
            except Exception as e:
                logger.warning(f"❌ Failed to initialize Groq: {e}")
                logger.warning("Will use Gemini only")
        else:
            logger.warning("No Groq API key configured. Will use Gemini only.")
        
        # Initialize Gemini (fallback or primary if Groq unavailable)
        try:
            self.gemini_client = GeminiClient(self.gemini_key_manager)
            if self.groq_client:
                logger.info(f"✅ Gemini client initialized (fallback) - {self.gemini_key_manager.get_total_keys()} key(s) available")
            else:
                logger.info(f"✅ Gemini client initialized (primary) - {self.gemini_key_manager.get_total_keys()} key(s) available")
        except Exception as e:
            logger.error(f"❌ Failed to initialize Gemini: {e}")
            if not self.groq_client:
                raise APIError(
                    "Neither Groq nor Gemini clients could be initialized.\n"
                    "Please set GROQ_API_KEY or GOOGLE_API_KEY in .env"
                )
    
    def generate_content(self, prompt: str, system_message: str = None) -> Tuple[str, str]:
        """
        Generate content using Groq with rotation, fallback to Gemini with rotation
        
        This method provides the core failover logic with key rotation:
        1. Try Groq with current key (with system message caching support)
        2. On rate limit → rotate to next Groq key, retry
        3. If all Groq keys exhausted → try Gemini
        4. On rate limit → rotate to next Gemini key, retry
        5. If all keys exhausted → raise exception
        
        Args:
            prompt: Input prompt for generation (user message)
            system_message: Optional system message (static content for caching)
        
        Returns:
            Tuple of (generated_text, provider_used)
            - generated_text: Generated content (trimmed)
            - provider_used: "groq" or "gemini"
        
        Raises:
            APIError: If all keys for both providers exhausted
        
        Example:
            >>> client = UnifiedLLMClient()
            >>> sql, provider = client.generate_content("How many?", system_message="Schema: ...")
            >>> print(f"Used: {provider}")  # "groq" or "gemini"
        """
        # Try Groq first (if available) with key rotation
        if self.groq_client and self.groq_key_manager:
            groq_attempts = 0
            max_groq_attempts = self.groq_key_manager.get_total_keys()
            
            while groq_attempts < max_groq_attempts:
                try:
                    logger.debug(f"Attempting generation with Groq (key {self.groq_key_manager.get_key_index()}/{max_groq_attempts})...")
                    start_time = time.time()
                    
                    model = self.groq_client.get_model()
                    response = model.generate_content(prompt, system_message=system_message)
                    
                    duration = time.time() - start_time
                    logger.info(f"✅ Groq succeeded in {duration:.2f}s (key {self.groq_key_manager.get_key_index()}/{max_groq_attempts})")
                    
                    return response.text.strip(), "groq"
                    
                except Exception as e:
                    error_msg = str(e)
                    
                    # Check if it's a rate limit error
                    if self.groq_key_manager.is_rate_limit_error(e):
                        logger.warning(f"❌ Groq rate limit hit (key {self.groq_key_manager.get_key_index()}/{max_groq_attempts})")
                        
                        # Try to rotate to next key
                        if self.groq_key_manager.rotate_key():
                            logger.info(f"→ Rotating to next Groq key ({self.groq_key_manager.get_key_index()}/{max_groq_attempts})...")
                            
                            # Reinitialize client with new key
                            try:
                                new_key = self.groq_key_manager.get_current_key()
                                self.groq_client = GroqClient(api_key=new_key)
                                groq_attempts += 1
                                continue  # Retry with new key
                            except Exception as init_error:
                                logger.error(f"Failed to reinitialize Groq with new key: {init_error}")
                                break  # Give up on Groq, try Gemini
                        else:
                            logger.warning("→ All Groq keys exhausted, falling back to Gemini...")
                            break  # All Groq keys failed, try Gemini
                    else:
                        # Non-rate-limit error, immediately fall back to Gemini
                        logger.warning(f"❌ Groq failed: {error_msg[:100]}")
                        logger.warning("→ Falling back to Gemini...")
                        break
        
        # Fallback to Gemini (or primary if Groq unavailable) with key rotation
        if self.gemini_client:
            gemini_attempts = 0
            max_gemini_attempts = self.gemini_key_manager.get_total_keys()
            
            # For Gemini, combine system_message with prompt (no caching support)
            gemini_prompt = prompt
            if system_message:
                gemini_prompt = f"{system_message}\n\n{prompt}"
            
            while gemini_attempts < max_gemini_attempts:
                try:
                    if self.groq_client:
                        logger.debug(f"Attempting fallback generation with Gemini (key {self.gemini_key_manager.get_key_index()}/{max_gemini_attempts})...")
                    else:
                        logger.debug(f"Attempting generation with Gemini (primary, key {self.gemini_key_manager.get_key_index()}/{max_gemini_attempts})...")
                    
                    start_time = time.time()
                    
                    model = self.gemini_client.get_model()
                    response = model.generate_content(gemini_prompt)
                    
                    duration = time.time() - start_time
                    logger.info(f"✅ Gemini succeeded in {duration:.2f}s (key {self.gemini_key_manager.get_key_index()}/{max_gemini_attempts})")
                    
                    return response.text.strip(), "gemini"
                    
                except Exception as e:
                    error_msg = str(e)
                    
                    # Check if it's a rate limit error
                    if self.gemini_key_manager.is_rate_limit_error(e):
                        logger.warning(f"❌ Gemini rate limit hit (key {self.gemini_key_manager.get_key_index()}/{max_gemini_attempts})")
                        
                        # Try to rotate to next key
                        if self.gemini_key_manager.rotate_key():
                            logger.info(f"→ Rotating to next Gemini key ({self.gemini_key_manager.get_key_index()}/{max_gemini_attempts})...")
                            
                            # Reinitialize client with new key
                            try:
                                self.gemini_client.reinitialize()
                                gemini_attempts += 1
                                continue  # Retry with new key
                            except Exception as init_error:
                                logger.error(f"Failed to reinitialize Gemini with new key: {init_error}")
                                gemini_attempts += 1
                                continue
                        else:
                            logger.error("→ All Gemini keys exhausted")
                            raise APIError(
                                f"All Gemini keys exhausted ({max_gemini_attempts} keys tried).\n"
                                f"Last error: {error_msg}"
                            )
                    else:
                        # Non-rate-limit error
                        logger.error(f"❌ Gemini failed: {error_msg[:100]}")
                        raise APIError(f"Gemini failed: {error_msg}")
            
            # If we get here, all Gemini attempts failed
            logger.error(f"❌ All {max_gemini_attempts} Gemini key(s) exhausted")
            
            if self.groq_client:
                raise APIError(
                    f"Both Groq and Gemini failed.\n"
                    f"Groq: All {self.groq_key_manager.get_total_keys()} keys exhausted\n"
                    f"Gemini: All {max_gemini_attempts} keys exhausted"
                )
            else:
                raise APIError(f"All {max_gemini_attempts} Gemini key(s) exhausted")
        
        # Should never reach here (caught in __init__)
        raise APIError("No LLM providers available")
    
    def get_model(self):
        """
        Get current model (for compatibility with existing code)
        
        Returns the primary available model (Groq if available, else Gemini)
        
        Returns:
            Model instance with generate_content() method
        
        Raises:
            APIError: If no models available
        """
        if self.groq_client:
            return self.groq_client.get_model()
        elif self.gemini_client:
            return self.gemini_client.get_model()
        else:
            raise APIError("No LLM models available")
    
    def get_model_name(self) -> str:
        """
        Get current model name for logging
        
        Shows which provider is primary and which is fallback.
        
        Returns:
            Model name with provider prefix
            
        Examples:
            "groq/llama-3.3-70b-versatile (primary) + gemini/gemini-2.0-flash-exp (fallback)"
            "gemini/gemini-2.0-flash-exp (primary only)"
        """
        names = []
        
        if self.groq_client:
            groq_name = self.groq_client.get_model_name()
            if self.gemini_client:
                names.append(f"groq/{groq_name} (primary)")
            else:
                names.append(f"groq/{groq_name} (primary only)")
        
        if self.gemini_client:
            gemini_name = self.gemini_client.get_model_name()
            if self.groq_client:
                names.append(f"gemini/{gemini_name} (fallback)")
            else:
                names.append(f"gemini/{gemini_name} (primary only)")
        
        return " + ".join(names) if names else "unknown"
    
    def reinitialize(self) -> None:
        """
        Reinitialize clients (useful after API key changes)
        
        This is called by SQLGenerator when rotating Gemini keys on rate limits.
        For Groq, it's a no-op (single key, no rotation needed).
        """
        logger.info("Reinitializing UnifiedLLMClient...")
        
        if self.gemini_client:
            try:
                self.gemini_client.reinitialize()
                logger.debug("Gemini client reinitialized")
            except Exception as e:
                logger.warning(f"Failed to reinitialize Gemini: {e}")
        
        if self.groq_client:
            try:
                self.groq_client.reinitialize()
                logger.debug("Groq client reinitialized")
            except Exception as e:
                logger.warning(f"Failed to reinitialize Groq: {e}")
